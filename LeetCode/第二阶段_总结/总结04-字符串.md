# 总结04：字符串

# 自定义术语映射

| 名称                        | 代号   | 说明                       |
| --------------------------- | ------ | -------------------------- |
| 时间复杂度                  | O(t)   |                            |
| 空间复杂度                  | O(s)   |                            |
| 前提                        | qt     |                            |
| 流程                        | lc     |                            |
| 目的                        | md     |                            |
| 说明                        | sm     |                            |
| 情况                        | qk     |                            |
| 算法                        | #sf    |                            |
| 结构                        | #jg    |                            |
| 解决思路                    | #sl    |                            |
| 多方法：multi-method        | #MM    | 该题可用多种相同优质的方法 |
| 循环表示次数                | @xh2   | 两次循环（1次可省略）      |
| 循环表示层数                | @xh#2  | 两层循环（1层可省略）      |
| 遍历                        | ~bl2   | 两次遍历（1次可省略）      |
| 优化                        | ~yh    |                            |
| 对应序号                    | 1=题目 | 序号一样的代表一样的题型   |
| 解答                        | ~jd    | 需要看解答的题目           |
| 第n种方法                   | ~ff-n  | 一道题的不同方法标识符     |
| 有/无问题 优化/劣质（以下） |        |                            |
| 效率                        | ~+-xl  | 高效率/低效率的方法        |
| 细节                        | ~+-xj  | 在某些细节处理需要注意     |
| 代码                        | ~+-dm  | 代码实现上没问题/存在问题  |
| 思维逻辑                    | ~+-sl  | 思维逻辑上存在难度的题目   |
| 知识点                      | ~+-zs  | 有需掌握的知识点           |
|                             |        |                            |

# 题表1：方法-思路-题型

| 名称：代号                         | 类型         | 需求                             | 前提                                                 | 运用场景                                                     | 功能                  | 题型                                                         |
| ---------------------------------- | ------------ | -------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------ | --------------------- | ------------------------------------------------------------ |
| 查找：Sear                         | #sf          | 查找                             | 求和target                                           |                                                              | 忽略：x不可与自己匹配 |                                                              |
| 二分查找：BSear                    | #sf          | 查找                             | 排序                                                 |                                                              | #yh：O(t)             |                                                              |
| 二分查找-插入位置：BSear-Pos       | #sf          | 找target，如果不在找对应插入位置 | 排序                                                 |                                                              |                       |                                                              |
| 二分查找-双数组：BSear-BArr        | #sf          | 查找第k大的元素                  | 排序                                                 |                                                              | 优化：O(t)            |                                                              |
| 双指针-滑动窗口：TP-Win            | #sl          |                                  |                                                      | 在某些遍历规则下可以运用                                     |                       | ML003：无重复字符的最长子串<br />HL076：最小覆盖子串         |
| 双指针-异向：TP-DD                 | #sl          | 遍历                             | 排序<br />一增一减                                   | 遍历时需要判断性的左增或者右减                               | 优化：O(t)            |                                                              |
| 双指针-同向：TP-SD<br />+覆盖：-fg | #sl          | 遍历                             | 排序                                                 | qk1：遍历时需要记录一些之前的位置时                          | 优化：O(s)            |                                                              |
| 双指针-同向-反向：TP-SD-RD         | #sl          | 遍历                             | 排序                                                 | 从后往前遍历                                                 | 优化：O(s)            |                                                              |
| 双指针-同向-快慢：TP-FS            | #sl          | 遍历                             |                                                      | 由快针的边界条件找慢针对应的位置                             |                       |                                                              |
| 双指针-位置：TP-Loc                | #jg          | 遍历                             |                                                      | 记录对应位置在符合条件的时候调用                             |                       |                                                              |
| 下一个排列：NP                     | #sl          |                                  |                                                      |                                                              |                       |                                                              |
| 哈希表-Set：HX-S                   | #jg          | ~bl                              | 0                                                    | 0                                                            | ~yh：O(t)             | EM01.01：判定字符是否唯一                                    |
| 哈希表-Map：HX-M                   | #jg          | ~bl                              | 0                                                    | 0                                                            | ~yh：O(t)             | EL013：罗马数字转整数<br />EO050：第一个只出现一次的字符     |
| 哈希-前缀：HX-Pre                  | #sl          | ~bl                              |                                                      | 适用于求连续子数组相关的问题                                 |                       |                                                              |
| 排序：Sort                         |              | 排序                             |                                                      |                                                              | ~yh：O(t)             |                                                              |
| 排序-堆：Sort-Heap                 |              |                                  |                                                      |                                                              |                       |                                                              |
| 排序-归并：Sort-Merge              | #sf          | 排序                             |                                                      |                                                              |                       |                                                              |
| 自定义规则排序：Sort-Rule          | #sf          | 自定义排序规则                   |                                                      | #sl                                                          |                       |                                                              |
| 规则拆分：Di-Rule                  | #sl          | ~bl                              | 拆分后的规则互相不影响<br />拆分用的规则可组成原规则 | 需要将规则拆分成一个一个单一的可逐步实现的规则               |                       |                                                              |
| 深度优先遍历：DFS                  | #sf          | ~bl                              | 类图的2维遍历                                        |                                                              |                       |                                                              |
| 广度优先遍历：BFS                  | #sf          | ~bl                              | 类图的2维遍历                                        |                                                              |                       | 1=HL297：二叉树的序列化与反序列化<br />1=HO037： 序列化二叉树 |
| 条件判断：Cod                      | #sl          | #sl                              | 分情况讨论                                           | 分情况讨论，往往还需要其他的结构或者思路                     |                       |                                                              |
| 数组引索：Arr-Idx                  | #sl          | #sl                              |                                                      |                                                              | ~yh：O(s)             |                                                              |
| 数组前缀和：Arr-PreSum             | #sl          | ~bl                              |                                                      |                                                              |                       |                                                              |
| 回溯-置换：BT-S                    | #sf          | ~bl                              |                                                      | 逐层遍历并恢复原状                                           |                       |                                                              |
| 回溯-条件：BT-Cd                   | #sf          | ~bl                              |                                                      | 条件判断是否回溯                                             |                       | ML022：括号生成<br />MO038：字符串的排列<br />ML093：复原 IP 地址\|<br />ML017：电话号码的字母组合<br />HL301：删除无效的括号 |
| 回溯-全部：BT-All                  | #sf          | ~bl                              |                                                      | 遍历所有情况                                                 |                       |                                                              |
| 动态规划-设为边界：DP-Bd           | #sf          | ~bl                              |                                                      | 每次遍历更新状态                                             |                       | ML005：最长回文子串                                          |
| 动态规划-背包：DP-Bg               | #sf          | ~bl                              |                                                      | 限制值求极值                                                 |                       |                                                              |
| 动态规划-状态：DP-St               | #sf          | ~bl                              |                                                      | 枚举所有单个子问题的状态 求得状态方程<br />状态1：独立状态<br />状态2：关系状态 |                       | MO046：把数字翻译成字符串<br />HL032：最长有效括号<br />ML516：最长回文子序列<br />HL44： 通配符匹配 |
| 动态规划-情况：DP-Cd               | #sf          | -bl                              |                                                      | 分情况讨论得出不同情况下的子结构最优解                       |                       | HL010：正则表达式匹配<br />HL072：编辑距离<br />ML139：单词拆分<br />MO048：最长不含重复字符的子字符串 |
| 位运算：Bit<br />+异或：-XOR       | #sl          |                                  |                                                      | 消除偶数相同数                                               |                       |                                                              |
| 模拟：MN                           | #sl          |                                  |                                                      | 模拟                                                         |                       | ML006：Z 字形变换<br />ML012：整数转罗马数字                 |
| 贪心：TX                           | #sl          |                                  |                                                      | 最优子结构推出最优解                                         |                       | ML678：有效的括号字符串                                      |
| 单调栈：STK-Mono                   | #jg<br />#sl | ~bl                              |                                                      | 适用于cur与pre多个数进行比较并且操作                         |                       | EL020：有效的括号<br />ML394：字符串解码<br />ML678：有效的括号字符串<br />ML227：基本计算器 II |
| 栈-功能：STK-Fun                   | #sl          |                                  |                                                      | 实现或利用栈的功能但并不一定用Stack结构来实现                |                       | ML316：去除重复字母<br />ML402：移掉 K 位数字                |
| 递归：RC                           | #sl          |                                  |                                                      | 当某一系列代码执行流程需要重复多次使用时                     |                       | HL224：基本计算器                                            |
| 链表节点-双向：Node-D              | #jg          |                                  |                                                      |                                                              |                       |                                                              |
| 链表节点-单向：Node-S              | #jg          |                                  |                                                      |                                                              |                       |                                                              |
| 迭代：DD                           | #sl          |                                  |                                                      |                                                              |                       |                                                              |
| ArrayList：ALst                    | #jg          |                                  |                                                      |                                                              |                       |                                                              |
| LinkedList：LLst                   | #jg          |                                  |                                                      |                                                              |                       |                                                              |
| 分治：DC                           | #sl          |                                  |                                                      |                                                              | ~yh：O(log(n))        |                                                              |
| 数学思路：Math                     | #sl          |                                  |                                                      | 用一些数学规则计算出解决问题的方法                           |                       |                                                              |
| 结构模型：JG                       | #sl          |                                  |                                                      |                                                              |                       | EO005：替换空格<br />ML208：实现 Trie (前缀树)               |
| 逻辑思路：LG                       | #sl          |                                  |                                                      |                                                              |                       | EL415：字符串相加<br />ML043：字符串相乘<br />EL557：反转字符串中的单词 III<br />1≈ML179：最大数<br />1≈MO045：把数组排成最小的数<br />EL344：反转字符串<br />ML071：简化路径<br />ML567：字符串的排列<br />EL387：字符串中的第一个唯一字符时<br />EM01.06：字符串压缩<br />EL125：验证回文串 |
| String                             | #sl          |                                  |                                                      | String的相关方法和技巧                                       |                       | ML165：比较版本号                                            |
| DFA                                | #sl          |                                  |                                                      | 确定有限状态机                                               |                       | ML008：字符串转换整数 (atoi                                  |
| 传世经典：CS                       | #sf          |                                  |                                                      | 传世经典                                                     |                       | EL028：实现 strStr()                                         |
|                                    |              |                                  |                                                      |                                                              |                       |                                                              |

# 题表2：功能-思路-优化

| #    | 题型样例                          | 技术代码                       | 思路码点     | 时间/空间        | 优化                                                         |
| ---- | --------------------------------- | ------------------------------ | ------------ | ---------------- | ------------------------------------------------------------ |
|      | ML003：无重复字符的最长子串       | TP-Win                         | #sl          | n ,  26          |                                                              |
|      | ML005：最长回文子串               | DP-Bd                          | #sf          | n^2^ , n^2^      | 1-提取字符：<br />1-xl：用String.charAt()提取某个字符<br />1+xl：将string转化为char array |
|      | EL014：最长公共前缀               |                                | #sl          | mn , 1           |                                                              |
|      | EL020：有效的括号                 | STK-Mono                       | #jg          | n , n            | 1-Stack.peek()：<br />1+xj：peek前需要判断是否为空           |
|      | ML022：括号生成                   | BT-Cd STK-Mono                 | #sf #jg      | ？, n            | 1-代替STK：<br />1+xl：单个变量代替                          |
|      | HL010：正则表达式匹配             | DP-Cd                          | #sf #sl      | mn , mn          |                                                              |
|      | MO038：字符串的排列               | BT-Cd                          | #sf          | nxn! , n         | 数组标记法VIS优于链表增删法list                              |
|      | HL072：编辑距离                   | DP-Cd                          | #sf          | mn , mn          |                                                              |
|      | EL013：罗马数字转整数             | HX-M                           | #jg #sl      | n , 7            |                                                              |
|      | EL415：字符串相加                 | LG                             | #sl          | max(m,n) , 1     | char-‘0’优于Integer.parseInt()                               |
|      | ML043：字符串相乘                 | LG                             | #sl          | mn , m+n         |                                                              |
|      | ML093：复原 IP 地址               | BT-Cd                          | #sf          | ? , ?            |                                                              |
|      | EM01.01：判定字符是否唯一         | HX-S                           | #jg          | n , n            |                                                              |
|      | ML394：字符串解码                 | STK-Mono                       | #jg          | S+s , S          | 可以用Character.isDigit() or Char.isLetter()                 |
|      | ML165：比较版本号                 | String                         | #sl          | m+n , m+n        |                                                              |
|      | ML006：Z 字形变换                 | MN                             | #sl          | n , n            | ans作为sb用append最后toString优于<br />ans作为String在for中不断加入sb |
|      | ML017：电话号码的字母组合         | BT-Cd                          | #sf          | 3^n^x4^m^ , m+n  |                                                              |
|      | ML008：字符串转换整数 (atoi)      | DFA                            | #sl          | n , 1            | 确定有限状态机（deterministic finite automaton, DFA）        |
|      | ML139：单词拆分                   | DP-Cd                          | #sf          | n^2^ , n         | Set可直接将List装入<br />Set<String> st = new HashSet(wordDict); |
|      | EL028：实现 strStr()              | CS                             | #sf          | n+m , m          |                                                              |
|      | ML012：整数转罗马数字             | MN                             | #sl          | 1 , 1            |                                                              |
|      | EO005：替换空格                   | LG                             | #sl          | n , 1            |                                                              |
|      | MO046：把数字翻译成字符串         | DP-St                          | #sf          | n , n            |                                                              |
|      | MO048：最长不含重复字符的子字符串 | DP-Cd                          | #sf          | n , 1            | Map.getOrDefault效率优于Map.containtKey()                    |
|      | EL557：反转字符串中的单词 III     | LG                             | #sl          | n , n            | SB.reverse()比for循环快                                      |
|      | ML179：最大数                     | LG                             | #sl          | ? , ?            | 整形大小比较优于String.compareTo()                           |
|      | MO045：把数组排成最小的数         | LG                             | #sl          | ? , ?            |                                                              |
|      | HL076：最小覆盖子串               | TP-Win                         | #sl          | ? , ?            | Set比Map更优                                                 |
|      | ML678：有效的括号字符串           | 1#STK-Mono<br />2#TX           | #jg<br />#sf | n , n<br />n , 1 |                                                              |
|      | ML1143：最长公共子序列            | DP-St                          | #sf          | mn , mn          |                                                              |
|      | ML451：根据字符出现频率排序       | Sort                           | #sl          | n+klogk ,  n+k   |                                                              |
|      | ML091：解码方法                   | DP-St                          | #sf          | n , 1            | 一维dp数组往往可以优化成O（1）空间                           |
|      | EO050：第一个只出现一次的字符     | HX-M                           | #jg          | n , n            |                                                              |
|      | ML227：基本计算器 II              | Stk-Mono                       | #jg          | n , n            | 字符串转化多位数用 tmp= 10*tmp + (c-‘0’)比<br />Integer.parseInt(sb.toString())更快 |
|      | ML316：去除重复字母               | Stk-Fun                        | #sl          | n , n            | 1. 数组计数优于Map（字母有26个所以可以用 new int[26])<br />2. 实现栈的功能未必一定要用栈去实现（sb实现栈功能最后无需反转）<br />    此处需要配合数组存储vis[]实现stk.contain()的功能 |
|      | EL344：反转字符串                 | LG                             | #sl          | n , 1            |                                                              |
|      | HL297：二叉树的序列化与反序列化   | BFS                            | #sf          | n , n            |                                                              |
|      | HL032：最长有效括号               | #mm1:DP-St<br />#mm2:LG        | #sf<br />#sl | n , n<br />n, 1  |                                                              |
|      | ML071：简化路径                   | LG                             | #sl          | n , n            |                                                              |
|      | ML516：最长回文子序列             | DP-St                          | #sf          | n^2^ , n^2^      |                                                              |
|      | HL224：基本计算器                 | #MM1(ZSX):RC<br />#MM2(~jd):LG | #sf<br />#sl | n , n<br />n , n |                                                              |
|      | ML567：字符串的排列               | LG                             | #sl          | m+n , 1          |                                                              |
|      | HO037： 序列化二叉树              | BFS                            | #sf          | n , n            | 同HL297                                                      |
|      | EL387：字符串中的第一个唯一字符时 | LG                             | #sl          | n , 1            |                                                              |
|      | EM01.06：字符串压缩               | LG                             | #sl          | n , n            |                                                              |
|      | ML402：移掉 K 位数字              | STK-FUN                        | #jg #sl      | n , n            |                                                              |
|      | EL125：验证回文串                 | LG                             | #sl          | n , n            |                                                              |
|      | HL301：删除无效的括号             | BT-Cd                          | #sf #sl      | nx2^n^ , n^2^    | 1. 剩余字符数<需要删除字符数，可跳过<br />2. 连续相同符号前面未remove，后面则不用（利用BT经典去重原理取代哈希去重） |
|      | HL44： 通配符匹配                 | DP-St                          | #sf          | mn , mn          |                                                              |
|      | ML208：实现 Trie (前缀树)         | JG                             | #jg          | n , n            |                                                              |

# 题表3：题序-技巧-注意

| 注释      | 题号    | 名称                       | 技巧or注意                                                   |
| --------- | ------- | -------------------------- | ------------------------------------------------------------ |
| ~xj       | ML003   | 无重复字符的最长子串       | 出循环后：<br />还需判断一次ans                              |
| ~yh       | ML005   | 最长回文子串               | 比String.charAt()更高效处理String                            |
| ~yh       | ML006   | Z 字形变换                 | ans作为sb用append最后toString优于<br />ans作为String在for中不断加入sb |
| ~yh       | ML008   | 字符串转换整数 (atoi)      | DFA                                                          |
| ~sl       | HL010   | 正则表达式匹配             | 状态方程的建立                                               |
|           | ML012   | 整数转罗马数字             |                                                              |
| ~zs       | EL013   | 罗马数字转整数             | 匿名代码块初始化                                             |
| -dm       | EL014   | 最长公共前缀               | 思路转代码                                                   |
|           | ML017   | 电话号码的字母组合         |                                                              |
| -dm-xj    | EL020   | 有效的括号                 | peek前判断                                                   |
| ~yh       | ML022   | 括号生成                   | 单个变量时间上优于Stack                                      |
| ~dm ~xj   | EL028   | 实现 strStr()              | 1. 关于next【】：<br />最长公共前后缀<br />首个值为-1<br />2. 关于getNest（）方法<br />当不相等时候：fir = next[fir] (or dp[fir]) |
| ~sl ~jd   | HL032   | 最长有效括号               | 方法1（zsx)：两次异序遍历<br />方法2（~jd）：动态规划        |
| ~sl ~jd-2 | ML043   | 字符串相乘                 | 逐位乘相加                                                   |
| ~dm ~jd   | HL044   | 通配符匹配                 | ZXS：<br />难1：边界条件的CD讨论(~jd) <br/>难2：递推过程中charP=‘*’时的CD讨论（~jd） |
| ~zs       | ML071   | 简化路径                   | String的判断相等用equals()，与比较用compareTo()的原因一样    |
| ~sl       | HL072   | 编辑距离                   | 状态方程的建立                                               |
|           | HL076   | 最小覆盖子串               | Set比Map更优                                                 |
| ~yh       | ML091   | 解码方法                   | 答案的动态规划思路更清晰<br />一维dp数组往往可以优化成O（1）空间 |
| ~xj       | ML093   | 复原 IP 地址               | 1. 最后一段处理的时候也要考虑0首位的问题<br />2. Integer.parseInt（）有长度限制，使用前先判断剩余字符串长度，可优化效率和防止该方法超出int规定长度 |
|           | EL125   | EL125：验证回文串          |                                                              |
| ~yh       | ML139   | 单词拆分                   | Set可直接将List装入<br />Set<String> st = new HashSet(wordDict); |
| ~zs       | ML165   | 比较版本号                 | (.)在正则表达式中表示任意字符，分割点（.）时采用String.split(“\\\\.”) |
| ~yh ~jd   | ML179   | 最大数                     | 整形大小比较优于String.compareTo()                           |
|           | ML208   | 实现 Trie (前缀树)         |                                                              |
| ~jd       | HL224   | 基本计算器                 | MM1:ZSX:RC<br />MM2:~jd                                      |
| ~yh ~jd   | ML227   | 基本计算器 II              | 字符串转化多位数用 tmp= 10*tmp + (c-‘0’)比<br />Integer.parseInt(sb.toString())更快<br /><br />不需要用逆波兰表达式（若没有括号的时候） |
| ~zs       | HL297   | 二叉树的序列化与反序列化   | String.compareTo比较值，而<br /> == 比较引用                 |
| ~yh ~jd   | HL301   | 删除无效的括号             | 1. 剩余字符数<需要删除字符数，可跳过<br />2. 连续相同符号前面未remove，后面则不用（利用BT经典去重原理取代哈希去重） |
| ~yh       | ML316   | 去除重复字母               | 1. 数组计数优于Map（字母有26个所以可以用 new int[26])<br />2. 实现栈的功能未必一定要用栈去实现（sb实现栈功能最后无需反转）<br />    此处需要配合数组存储vis[]实现stk.contain()的功能 |
|           | EL387   | 字符串中的第一个唯一字符   |                                                              |
| ~zs       | ML394   | 字符串解码                 | 可以用Character.isDigit() or Char.isLetter()                 |
|           | EL344   | 反转字符串                 |                                                              |
| ~yh       | ML402   | 移掉 K 位数字              | 1. 数组实现Stack更优<br />2. 非Stack实现后如果需要转化为string不用进行反转reverse()操作（根据实际情况） |
| ~yh ~zs   | EL415   | 字符串相加                 | char-‘0’优于Integer.parseInt()<br />字符串反转s.reverse()    |
|           | ML451   | 根据字符出现频率排序       |                                                              |
| ~jd       | ML516   | 最长回文子序列             | -状态判断<br />-                                             |
| ~yh       | EL557   | 反转字符串中的单词 III     | SB.reverse()比for循环快<br />                                |
|           | ML567   | 字符串的排列               |                                                              |
| ~jd       | ML678   | 有效的括号字符串           | STK 和 TX 两种方法                                           |
| ~jd       | ML1143  | 最长公共子序列             | 经典动态规划二维数组                                         |
|           |         |                            |                                                              |
|           | EO005   | 替换空格                   |                                                              |
|           | HL037   | 序列化二叉树               | 同HL297                                                      |
| ~yh ~jd-1 | MO038   | 字符串的排列               | 数组标记法VIS优于链表增删法list                              |
|           | MO045   | 把数组排成最小的数         |                                                              |
|           | MO046   | 把数字翻译成字符串         |                                                              |
| ~yh       | MO048   | 最长不含重复字符的子字符串 | Map.getOrDefault效率优于Map.containtKey()                    |
| -zs       | MO050   | 第一个只出现一次的字符     | 遍历本身具有顺序性，故可以两次遍历（第二次找第一个唯一符号） |
|           |         |                            |                                                              |
|           | EM01.01 | 判定字符是否唯一           |                                                              |
|           | EM01.06 | 字符串压缩                 |                                                              |

# 功能流程

| 代号 | 流程 |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

# 零散知识

| 名称：代号 | 详细说明 | 作用 |
| ---------- | -------- | ---- |
|            |          |      |
|            |          |      |
|            |          |      |

# 代码功能最优实现方法

| 功能代号：代号 | 功能需求 | 功能实现 |
| -------------- | -------- | -------- |
|                |          |          |
|                |          |          |
|                |          |          |
|                |          |          |
|                |          |          |
|                |          |          |
|                |          |          |

# Q&A

| Detail | Q    | A    |
| ------ | ---- | ---- |
|        |      |      |
|        |      |      |
|        |      |      |

# 
