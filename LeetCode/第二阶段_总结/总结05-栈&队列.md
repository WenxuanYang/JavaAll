# 总结05：栈&队列

# 自定义术语映射

| 名称                        | 代号   | 说明                       |
| --------------------------- | ------ | -------------------------- |
| 时间复杂度                  | O(t)   |                            |
| 空间复杂度                  | O(s)   |                            |
| 前提                        | qt     |                            |
| 流程                        | lc     |                            |
| 目的                        | md     |                            |
| 说明                        | sm     |                            |
| 情况                        | qk     |                            |
| 算法                        | #sf    |                            |
| 结构                        | #jg    |                            |
| 解决思路                    | #sl    |                            |
| 多方法：multi-method        | #MM    | 该题可用多种相同优质的方法 |
| 循环表示次数                | @xh2   | 两次循环（1次可省略）      |
| 循环表示层数                | @xh#2  | 两层循环（1层可省略）      |
| 遍历                        | ~bl2   | 两次遍历（1次可省略）      |
| 优化                        | ~yh    |                            |
| 对应序号                    | 1=题目 | 序号一样的代表一样的题型   |
| 解答                        | ~jd    | 需要看解答的题目           |
| 第n种方法                   | ~ff-n  | 一道题的不同方法标识符     |
| 有/无问题 优化/劣质（以下） |        |                            |
| 效率                        | ~+-xl  | 高效率/低效率的方法        |
| 细节                        | ~+-xj  | 在某些细节处理需要注意     |
| 代码                        | ~+-dm  | 代码实现上没问题/存在问题  |
| 思维逻辑                    | ~+-sl  | 思维逻辑上存在难度的题目   |
| 知识点                      | ~+-zs  | 有需掌握的知识点           |
| 存在问题                    | ~+-qe  | 未解决的问题               |

# 题表1：方法-思路-题型

| 名称：代号                         | 类型         | 需求                             | 前提                                                 | 运用场景                                                     | 功能                  | 题型                                                         |
| ---------------------------------- | ------------ | -------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------ | --------------------- | ------------------------------------------------------------ |
| 查找：Sear                         | #sf          | 查找                             | 求和target                                           |                                                              | 忽略：x不可与自己匹配 |                                                              |
| 二分查找：BSear                    | #sf          | 查找                             | 排序                                                 |                                                              | #yh：O(t)             |                                                              |
| 二分查找-插入位置：BSear-Pos       | #sf          | 找target，如果不在找对应插入位置 | 排序                                                 |                                                              |                       |                                                              |
| 二分查找-双数组：BSear-BArr        | #sf          | 查找第k大的元素                  | 排序                                                 |                                                              | 优化：O(t)            |                                                              |
| 双指针-滑动窗口：TP-Win            | #sl          |                                  |                                                      | 在某些遍历规则下可以运用                                     |                       |                                                              |
| 双指针-异向：TP-DD                 | #sl          | 遍历                             | 排序<br />一增一减                                   | 遍历时需要判断性的左增或者右减                               | 优化：O(t)            |                                                              |
| 双指针-同向：TP-SD<br />+覆盖：-fg | #sl          | 遍历                             | 排序                                                 | qk1：遍历时需要记录一些之前的位置时                          | 优化：O(s)            |                                                              |
| 双指针-同向-反向：TP-SD-RD         | #sl          | 遍历                             | 排序                                                 | 从后往前遍历                                                 | 优化：O(s)            | HM17.21：直方图的水量                                        |
| 双指针-同向-快慢：TP-FS            | #sl          | 遍历                             |                                                      | 由快针的边界条件找慢针对应的位置                             |                       |                                                              |
| 双指针-位置：TP-Loc                | #jg          | 遍历                             |                                                      | 记录对应位置在符合条件的时候调用                             |                       |                                                              |
| 下一个排列：NP                     | #sl          |                                  |                                                      |                                                              |                       |                                                              |
| 哈希表-Set：HX-S                   | #jg          | ~bl                              | 0                                                    | 0                                                            | ~yh：O(t)             |                                                              |
| 哈希表-Map：HX-M                   | #jg          | ~bl                              | 0                                                    | 0                                                            | ~yh：O(t)             |                                                              |
| 哈希-前缀：HX-Pre                  | #sl          | ~bl                              |                                                      | 适用于求连续子数组相关的问题                                 |                       |                                                              |
| 排序：Sort                         |              | 排序                             |                                                      |                                                              | ~yh：O(t)             |                                                              |
| 排序-堆：Sort-Heap                 |              |                                  |                                                      |                                                              |                       |                                                              |
| 排序-归并：Sort-Merge              | #sf          | 排序                             |                                                      |                                                              |                       |                                                              |
| 自定义规则排序：Sort-Rule          | #sf          | 自定义排序规则                   |                                                      | #sl                                                          |                       |                                                              |
| 规则拆分：Di-Rule                  | #sl          | ~bl                              | 拆分后的规则互相不影响<br />拆分用的规则可组成原规则 | 需要将规则拆分成一个一个单一的可逐步实现的规则               |                       |                                                              |
| 深度优先遍历：DFS                  | #sf          | ~bl                              | 类图的2维遍历                                        |                                                              |                       |                                                              |
| 广度优先遍历：BFS                  | #sf          | ~bl                              | 类图的2维遍历                                        |                                                              |                       |                                                              |
| 条件判断：Cod                      | #sl          | #sl                              | 分情况讨论                                           | 分情况讨论，往往还需要其他的结构或者思路                     |                       |                                                              |
| 数组引索：Arr-Idx                  | #sl          | #sl                              |                                                      |                                                              | ~yh：O(s)             |                                                              |
| 数组前缀和：Arr-PreSum             | #sl          | ~bl                              |                                                      |                                                              |                       |                                                              |
| 回溯-置换：BT-S                    | #sf          | ~bl                              |                                                      | 逐层遍历并恢复原状                                           |                       |                                                              |
| 回溯-条件：BT-Cd                   | #sf          | ~bl                              |                                                      | 条件判断是否回溯                                             |                       |                                                              |
| 回溯-全部：BT-All                  | #sf          | ~bl                              |                                                      | 遍历所有情况                                                 |                       |                                                              |
| 动态规划-设为边界：DP-Bd           | #sf          | ~bl                              |                                                      | 每次遍历更新状态                                             |                       |                                                              |
| 动态规划-背包：DP-Bg               | #sf          | ~bl                              |                                                      | 限制值求极值                                                 |                       |                                                              |
| 动态规划-状态：DP-St               | #sf          | ~bl                              |                                                      | 枚举所有单个子问题的状态 求得状态方程<br />状态1：独立状态<br />状态2：关系状态 |                       |                                                              |
| 动态规划-情况：DP-Cd               | #sf          | -bl                              |                                                      | 分情况讨论得出不同情况下的子结构最优解                       |                       |                                                              |
| 位运算：Bit<br />+异或：-XOR       | #sl          |                                  |                                                      | 消除偶数相同数                                               |                       |                                                              |
| 模拟：MN                           | #sl          |                                  |                                                      | 模拟                                                         |                       |                                                              |
| 贪心：TX                           | #sl          |                                  |                                                      | 最优子结构推出最优解                                         |                       | ML678：有效的括号字符串                                      |
| 单调栈：STK-Mono                   | #jg<br />#sl | ~bl                              |                                                      | 适用于cur与pre多个数进行比较并且操作                         |                       | EL020：有效的括号<br />HL084：柱状图中最大的矩形<br />ML739：每日温度<br />EO06：从尾到头打印链表<br />EO030：包含min函数的栈<br />ML150：逆波兰表达式求值<br />EL232：用栈实现队列<br />ML1190：反转每对括号间的子串 |
| 栈-功能：STK-Fun                   | #sl          |                                  |                                                      | 实现或利用栈的功能但并不一定用Stack结构来实现                |                       | EL155：最小栈<br />ML316：去除重复字母<br />ML227：基本计算器 II<br />ML402：移掉 K 位数字<br />ML735：行星碰撞<br />EL496：下一个更大元素 I<br />HL085：最大矩形<br />MM16.26：计算器<br />ML503：下一个更大元素 II<br />ML907：子数组的最小值之和<br />ML946：验证栈序列<br />ML1081：不同字符的最小子序列 |
| 递归：RC                           | #sl          |                                  |                                                      | 当某一系列代码执行流程需要重复多次使用时                     |                       | ML394：字符串解码<br />EL145：二叉树的后序遍历<br />HL224：基本计算器<br />MO036： 二叉搜索树与双向链表<br />EL094：二叉树的中序遍历<br />ML856： 括号的分数<br />MO033：二叉搜索树的后序遍历序列<br />ML654：最大二叉树<br />EL589：N 叉树的前序遍历<br />ML341：扁平化嵌套列表迭代器 |
| 链表节点-双向：Node-D              | #jg          |                                  |                                                      |                                                              |                       |                                                              |
| 链表节点-单向：Node-S              | #jg          |                                  |                                                      |                                                              |                       |                                                              |
| 迭代：DD                           | #sl          |                                  |                                                      |                                                              |                       |                                                              |
| ArrayList：ALst                    | #jg          |                                  |                                                      |                                                              |                       |                                                              |
| LinkedList：LLst                   | #jg          |                                  |                                                      |                                                              |                       |                                                              |
| 分治：DC                           | #sl          |                                  |                                                      |                                                              | ~yh：O(log(n))        |                                                              |
| 数学思路：Math                     | #sl          |                                  |                                                      | 用一些数学规则计算出解决问题的方法                           |                       |                                                              |
| 结构模型：JG                       | #sl          |                                  |                                                      |                                                              |                       |                                                              |
| 逻辑思路：LG                       | #sl          |                                  |                                                      |                                                              |                       | EO09：用两个栈实现队列<br />HL042：接雨水时<br />ML143：重排链表<br />HL032：最长有效括号<br />ML234：回文链表<br />ML71：简化路径<br />ML581：最短无序连续子数组<br />MO2-025：链表中的两数相加<br />HL726：原子的数量<br />ML114： 二叉树展开为链表<br />EL144：二叉树的前序遍历<br />EL225：用队列实现栈<br />ML445：两数相加 II<br />ML456：132 模式<br />MO2-026：重排链表<br />EM03.02：栈的最小值<br />ML1249：移除无效的括号 |
| String                             | #sl          |                                  |                                                      | String的相关方法和技巧                                       |                       |                                                              |
| DFA                                | #sl          |                                  |                                                      | 确定有限状态机                                               |                       |                                                              |
| 传世经典：CS                       | #sf          |                                  |                                                      | 传世经典                                                     |                       |                                                              |
|                                    |              |                                  |                                                      |                                                              |                       |                                                              |

# 题表2：功能-思路-优化

| #    | 题型样例                             | 技术代码    | 思路码点 | 时间/空间 | 优化                                                         |
| ---- | ------------------------------------ | ----------- | -------- | --------- | ------------------------------------------------------------ |
| 1    | EO09：用两个栈实现队列               | LG          | #sl      |           |                                                              |
| 2    | HL042：接雨水                        | LG          | #sl      |           |                                                              |
| 3    | EL020：有效的括号                    | STK-Mono    | #jg      |           |                                                              |
| 4    | ML143：重排链表                      | LG          | #sl      |           | ~jd：思路优化                                                |
| 5    | ML394：字符串解码                    | RC          | #sf      |           |                                                              |
| 6    | HL084：柱状图中最大的矩形            | STK-Mono LG | #jg #sl  |           |                                                              |
| 7    | ML739：每日温度                      | STK-Mono LG | #jg #sl  |           |                                                              |
| 8    | EO06：从尾到头打印链表               | STK-Mono    | #jg      |           |                                                              |
| 9    | HL032：最长有效括号                  | LG          | #sl      |           |                                                              |
| 10   | EL234：回文链表                      | LG          | #sl      |           |                                                              |
| 11   | EL155：最小栈                        | STK-FUN     | #jg      |           | Deque.push()和pop()快于Stack                                 |
| 12   | EL145：二叉树的后序遍历              | RC          | #sf      |           |                                                              |
| 13   | ML71：简化路径                       | LG          | #sl      |           | ArrayList优于ArrayDeque                                      |
| 14   | ML678：有效的括号字符串              | TX          | #sf      |           |                                                              |
| 15   | ML316：去除重复字母                  | STK-Fun     | #jg      |           | 用sb直接实现stk优于<br />用stk然后加入sb然后反转             |
| 16   | HL224：基本计算器                    | RC          | #sf      |           |                                                              |
| 17   | MO036： 二叉搜索树与双向链表         | RC          | #sf      |           |                                                              |
| 18   | EO030：包含min函数的栈               | STK-Mono    | #jg #sl  |           |                                                              |
| 19   | ML581：最短无序连续子数组            | LG          | #sl      |           |                                                              |
| 20   | EL094：二叉树的中序遍历              | RC          | #sf      |           |                                                              |
| 21   | ML227：基本计算器 II                 | STK-Fun     | #jg #sl  |           |                                                              |
| 22   | ML402：移掉 K 位数字                 | STK-Fun     | #jg #sl  |           | 数组实现优化时间~jd                                          |
| 23   | ML735：行星碰撞                      | STK-Fun     | #jg #sl  |           |                                                              |
| 24   | ML856： 括号的分数                   | RC          | #sf      |           |                                                              |
| 25   | EL496：下一个更大元素 I              | STK-Fun     | #jg #sl  |           |                                                              |
| 26   | EL1047：删除字符串中的所有相邻重复项 | STK-Fun     | #jg #sl  |           | 此处sb优于deque                                              |
| 27   | HM17.21：直方图的水量                | TP-SD-RD    | #sf      |           |                                                              |
| 28   | HL085：最大矩形                      | STK-FUN     | #jg #sl  |           |                                                              |
| 29   | ML150：逆波兰表达式求值              | STK-Mono    | #jg      |           |                                                              |
| 30   | MM16.26：计算器                      | STK-FUN     | #jg #sl  |           |                                                              |
| 31   | EL232：用栈实现队列                  | STK-Mono    |          |           |                                                              |
| 32   | ML503：下一个更大元素 II             | STK-FUN     | #jg      |           | 1. 循环次数加长，不用复制数组<br />2. 循环代码可更优化       |
| 33   | MO2-025：链表中的两数相加            | LG          | #sl      |           | reverse链表时间上优于在List中处理ListNode                    |
| 34   | MO033：二叉搜索树的后序遍历序列      | RC          | #sf #sl  |           |                                                              |
| 35   | ML654：最大二叉树                    | RC          | #sf #sl  |           |                                                              |
| 36   | HL726：原子的数量                    | LG          | #sl      |           |                                                              |
| 37   | ML114： 二叉树展开为链表             | LG          | #sl      |           |                                                              |
| 38   | EL144：二叉树的前序遍历              | LG          | #sl      |           |                                                              |
| 39   | EL225：用队列实现栈                  | LG          | #sl      |           |                                                              |
| 40   | ML445：两数相加 II                   | LG          | #sl      |           | 反转链表更优但略复杂                                         |
| 41   | ML456：132 模式                      | LG          | #sl      |           | 倒序遍历更简单（正序不会)                                    |
| 42   | MO2-026：重排链表                    | LG          | #sl      |           |                                                              |
| 43   | ML907：子数组的最小值之和            | STK-FUN     | #jg #sl  |           | KDA2                                                         |
| 44   | ML1190：反转每对括号间的子串         | STK-Mono    | #jg #sl  |           |                                                              |
| 45   | EM03.02：栈的最小值                  | LG          | #sl      |           |                                                              |
| 46   | ML946：验证栈序列                    | STK-FUN     | #sl      |           |                                                              |
| 47   | ML1081：不同字符的最小子序列         | STK-FUN     | #jg #sl  |           |                                                              |
| 48   | EL589：N 叉树的前序遍历              | RC          | #sf      |           |                                                              |
| 49   | ML341：扁平化嵌套列表迭代器          | RC          | #sf      |           |                                                              |
| 50   | ML1249：移除无效的括号               | LG          | #sl      |           | ZSX:LG<br/>~yh：STK-Mono<br />用两个Stack分别记录没有抵消（多了或者不符合规定）的左（右）括号的idx，最后从后往前删除 |

# 题表3：题序-技巧-注意

| 注释    | 题号    | 名称                         | 技巧or注意                                                   |
| ------- | ------- | ---------------------------- | ------------------------------------------------------------ |
|         | EL020   | 有效的括号                   |                                                              |
|         | HL032   | 最长有效括号                 |                                                              |
|         | HL042   | 接雨水                       |                                                              |
|         | ML071   | 简化路径                     | ArrayList优于ArrayDeque                                      |
| ~yh     | HL084   | 柱状图中最大的矩形           | ~jd：思路可以向着时间优化的方向调整，具体KDA方法2中代码      |
| ~qe     | HL085   | 最大矩形                     | 和答案的栈的时间执行率一样但是不够快（20%左右）              |
|         | EL094   | 二叉树的中序遍历             |                                                              |
|         | ML114   | 二叉树展开为链表             |                                                              |
| ~yh     | ML143   | 重排链表                     | ~jd：思路优化<br />找中点 + 反转 + 合并<br />优化原因分析（可能）<br />list.get(i)是一个一个遍历，比ListNode.next慢 |
|         | EL144   | 二叉树的前序遍历             |                                                              |
|         | EL145   | 二叉树的后序遍历             |                                                              |
|         | ML150   | 逆波兰表达式求值             |                                                              |
| ~yh     | EL155   | 最小栈                       | Deque.push()和pop()快于Stack                                 |
|         | HL224   | 基本计算器                   |                                                              |
|         | EL225   | 用队列实现栈                 |                                                              |
|         | ML227   | 基本计算器 II                |                                                              |
|         | EL232   | 用栈实现队列                 |                                                              |
|         | EL234   | 回文链表                     |                                                              |
| ~yh     | ML316   | 去除重复字母                 | 用sb直接实现stk优于<br />用stk然后加入sb然后反转             |
| ~zs     | ML341   | 扁平化嵌套列表迭代器         | 获取需要的类型并进行判断                                     |
| ~dm     | ML394   | 字符串解码                   | ZXS:RC<br/>1. 注意数字的重置为0的情况<br/>2. 注意需要同时返回当前索引和当前字符串，返回类型用object[] |
| ~yh     | ML402   | 移掉 K 位数字                | 数组实现优化时间~jd                                          |
| ~yh     | ML445   | 两数相加 II                  | 反转链表时间优于List处理但更复杂                             |
| ~jd     | ML456   | 132 模式                     | 倒序遍历更简单（正序不会)                                    |
|         | EL496   | 下一个更大元素 I             |                                                              |
| ~yh     | ML503   | 下一个更大元素 II            | 1. 循环次数加长，不用复制数组<br />2. 循环代码可更优化       |
| ~jd     | ML581   | 最短无序连续子数组           | 不需要用STK，~jd                                             |
|         | EL589   | N 叉树的前序遍历             |                                                              |
|         | ML654   | 最大二叉树                   |                                                              |
| ~sl     | ML678   | 有效的括号字符串             | ZXS:TX<br />1.星号有三种状态，预设值为右括号，不断向右遍历，判断是否需要通过转换星号来保证左右括号相等（如果有可用的星号）<br />2.向右遍历，星号预设值为‘)’（因为只有前面的星号可以变换，而*(这种情况，\*变成)是不满足的，所以提前假设\*为‘)’，然后根据prt判断是否要将‘)’变成null或者将null变成’(‘ |
| ~zs     | HL726   | 原子的数量                   | （答案中）也可以用Stack<Map<String,Integer>>的方法分割不同括号层的所有元素字母 |
|         | ML735   | 行星碰撞                     |                                                              |
|         | ML739   | 每日温度                     |                                                              |
|         | ML856   | 括号的分数                   |                                                              |
| ~jd     | ML907   | 子数组的最小值之和           | KDA2最优：最小值在子数组最右的集合（向单边延伸）<br />KDA1次优：当i为最小值时的集合（向两边延伸） |
|         | ML946   | 验证栈序列                   |                                                              |
| ~yh     | EL1047  | 删除字符串中的所有相邻重复项 | 此处sb优于deque                                              |
|         | ML1081  | 不同字符的最小子序列         |                                                              |
|         | ML1190  | 反转每对括号间的子串         |                                                              |
| ZSX ~yh | ML1249  | 移除无效的括号               | ZSX:LG<br/>~yh：STK-Mono<br />用两个Stack分别记录没有抵消（多了或者不符合规定）的左（右）括号的idx，最后从后往前删除 |
|         |         |                              |                                                              |
|         | EO06    | 从尾到头打印链表             |                                                              |
| ~sl     | EO09    | 用两个栈实现队列             | ~jd：更优                                                    |
|         | EO030   | 包含min函数的栈              |                                                              |
|         | MO033   | 二叉搜索树的后序遍历序列     |                                                              |
| ~sl     | MO036   | 二叉搜索树与双向链表         | 思路上竟可能在不影响太多空间和时间的情况下，将功能拆分开比如此题拆分成<br />1. 按顺序遍历并且加入list<br />2. 按顺序建立左右链接<br />此思路的思维复杂度和功能独立性要远优于思考如何在递归条件下同时完成顺序遍历和简历链接 |
|         |         |                              |                                                              |
| ~yh     | MO2-025 | 链表中的两数相加             | reverse链表时间上优于在List中处理ListNode                    |
| ~xl     | MO2-026 | 重排链表                     | LinkedList超时<br />同ML143                                  |
|         |         |                              |                                                              |
|         | EM03.02 | 栈的最小值                   |                                                              |
|         | MM16.26 | 计算器                       |                                                              |
|         | HM17.21 | 直方图的水量                 |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |
|         |         |                              |                                                              |

# 功能流程

| 代号 | 流程 |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

# 零散知识

| 名称：代号                                    | 详细说明                                                     | 作用     |
| --------------------------------------------- | ------------------------------------------------------------ | -------- |
| 区别：Integer.parseInt() vs Integer.valueOf() | Integer.parseInt(s)是把字符串解析成int基本类型，Integer.valueOf(s)是把字符串解析成Integer对象类型，其实int就是Integer解包装，Integer就是int的包装，在jdk8中已经自动实现了自动解包装和自动包装，所以两种方式都能得到想要的整数值。 | 基本等价 |
|                                               |                                                              |          |
|                                               |                                                              |          |

# 代码功能最优实现方法

| 功能代号：代号 | 功能需求 | 功能实现 |
| -------------- | -------- | -------- |
|                |          |          |
|                |          |          |
|                |          |          |
|                |          |          |
|                |          |          |
|                |          |          |
|                |          |          |

# Q&A

| Detail | Q    | A    |
| ------ | ---- | ---- |
|        |      |      |
|        |      |      |
|        |      |      |

# 
