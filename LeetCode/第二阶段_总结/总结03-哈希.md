# 总结03：哈希表

# 专业术语映射

| 名称                 | 代号   |                          |
| -------------------- | ------ | ------------------------ |
| 时间复杂度           | O(t)   |                          |
| 空间复杂度           | O(s)   |                          |
| 前提                 | qt     |                          |
| 流程                 | lc     |                          |
| 目的                 | md     |                          |
| 说明                 | sm     |                          |
| 情况                 | qk     |                          |
| 算法                 | #sf    |                          |
| 结构                 | #jg    |                          |
| 解决思路             | #sl    |                          |
| 循环表示次数         | @xh2   | 两次循环（1次可省略）    |
| 循环表示层数         | @xh#2  | 两层循环（1层可省略）    |
| 遍历                 | ~bl2   | 两次遍历（1次可省略）    |
| 优化                 | ~yh    |                          |
| 对应序号一模一样的题 | 1=题目 | 序号一样的代表一样的题型 |
| 代码逻辑有难度       | @dm    | 代码逻辑上存在难度的题目 |
| 思维逻辑有难度       | @sl    | 思维逻辑上存在难度的题目 |
| 需要看解答的题目     | @jd    | 等待看的答案             |
| 第n种方法            | @ff-n  | 一道题的不同方法标识符   |

# 方法思路总结

| 名称：代号                         | 类型         | 需求                             | 前提                                                 | 运用场景                                       | 功能                        | 题型                                                         |
| ---------------------------------- | ------------ | -------------------------------- | ---------------------------------------------------- | ---------------------------------------------- | --------------------------- | ------------------------------------------------------------ |
| 查找：Sear                         | #sf          | 查找                             | 求和target                                           |                                                | 忽略：x不可与自己匹配       |                                                              |
| 二分查找：BSear                    | #sf          | 查找                             | 排序                                                 |                                                | #yh：O(t)                   | EO53：0～n-1中缺失的数字                                     |
| 二分查找-插入位置：BSear-Pos       | #sf          | 找target，如果不在找对应插入位置 | 排序                                                 |                                                |                             |                                                              |
| 二分查找-双数组：BSear-BArr        | #sf          | 查找第k大的元素                  | 排序                                                 |                                                | 优化：O(t)                  |                                                              |
| 双指针-异向：TP-DD                 | #sl          | 遍历                             | 排序<br />一增一减                                   | 遍历时需要判断性的左增或者右减                 | 优化：O(t)                  | MO48：最长不含重复字符的子字符串<br />1=EO52：两个链表的第一个公共节点<br />1=EL160：相交链表 |
| 双指针-同向：TP-SD<br />+覆盖：-fg | #sl          | 遍历                             | 排序                                                 | qk1：遍历时需要记录一些之前的位置时            | 优化：O(s)                  |                                                              |
| 双指针-同向-反向：TP-SD-RD         | #sl          | 遍历                             | 排序                                                 | 从后往前遍历                                   | 优化：O(s)                  |                                                              |
| 双指针-同向-快慢：TP-FS            | #sl          | 遍历                             |                                                      | 由快针的边界条件找慢针对应的位置               |                             | EL141：环形链表<br />ML142：环形链表 II                      |
| 双指针-位置：TP-Loc                | #jg          | 遍历                             |                                                      | 记录对应位置在符合条件的时候调用               |                             |                                                              |
| 下一个排列：NP                     | #sl          |                                  |                                                      |                                                |                             |                                                              |
| 哈希表-Set：HX-S                   | #jg          | ~bl                              | 0                                                    | 0                                              | ~yh：O(t)                   | 1=EL217：存在重复元素<br />1=EO03：数组中重复的数字<br />EM01.01：判定字符是否唯一<br />EL349：两个数组的交集<br />ML12：整数转罗马数字 |
| 哈希表-Map：HX-M                   | #jg          | ~bl                              | 0                                                    | 0                                              | ~yh：O(t)                   | 1=ML146：LRU 缓存机制<br />1=MM16.25：LRU 缓存<br />ML128：最长连续序列<br />EL013：罗马数字转整数<br />EL169：多数元素<br />ML347：前 K 个高频元素<br />ML1488：避免洪水泛滥<br />ML451：根据字符出现频率排序<br />HL149：直线上最多的点数<br />2=EL387：字符串中的第一个唯一字符<br />2=EO50：第一个只出现一次的字符<br />ML454：四数相加 II<br />ML49：字母异位词分组 |
| 哈希-前缀：HX-Pre                  | #sl          | ~bl                              |                                                      | 适用于求连续子数组相关的问题                   |                             |                                                              |
| 排序：Sort                         |              | 排序                             |                                                      |                                                | ~yh：O(t)                   |                                                              |
| 排序-堆：Sort-Heap                 |              |                                  |                                                      |                                                |                             |                                                              |
| 排序-归并：Sort-Merge              | #sf          | 排序                             |                                                      |                                                |                             |                                                              |
| 自定义规则排序：Sort-Rule          | #sf          | 自定义排序规则                   |                                                      | #sl                                            |                             |                                                              |
| 规则拆分：Di-Rule                  | #sl          | ~bl                              | 拆分后的规则互相不影响<br />拆分用的规则可组成原规则 | 需要将规则拆分成一个一个单一的可逐步实现的规则 |                             |                                                              |
| 深度优先遍历：DFS                  | #sf          | ~bl                              | 类图的2维遍历                                        |                                                |                             |                                                              |
| 广度优先遍历：BFS                  | #sf          | ~bl                              | 类图的2维遍历                                        |                                                |                             | HL815：公交路线                                              |
| 条件判断：Cod                      | #sl          | #sl                              | 分情况讨论                                           | 分情况讨论，往往还需要其他的结构或者思路       |                             |                                                              |
| 数组引索：Arr-Idx                  | #sl          | #sl                              |                                                      |                                                | ~yh：O(s)                   | HL41：缺失的第一个正数                                       |
| 数组前缀和：Arr-PreSum             | #sl          | ~bl                              |                                                      |                                                |                             | ML560：和为 K 的子数组<br />ML525：连续数组                  |
| 回溯-置换：BT-S                    | #sf          | ~bl                              |                                                      | 逐层遍历并恢复原状                             |                             |                                                              |
| 回溯-条件：BT-Cd                   | #sf          | ~bl                              |                                                      | 条件判断是否回溯                               |                             | ML17：电话号码的字母组合<br />1=ML105：从前序与中序遍历序列构造二叉树<br />1=MO07：重建二叉树<br />2=ML138：复制带随机指针的链表<br />2=MO35：复杂链表的复制 |
| 回溯-全部：BT-All                  | #sf          | ~bl                              |                                                      | 遍历所有情况                                   |                             |                                                              |
| 动态规划-设为边界：DP-Bd           | #sf          | ~bl                              |                                                      | 每次遍历更新状态                               |                             | ML139：单词拆分                                              |
| 动态规划-背包：DP-Bg               | #sf          | ~bl                              |                                                      | 限制值求极值                                   |                             |                                                              |
| 动态规划-情况：DP-Cd               | #sf          | -bl                              |                                                      | 分情况讨论得出不同情况下的子结构最优解         |                             | 1=MO49：丑数<br />1=ML264：丑数 II                           |
| 位运算：Bit<br />+异或：-XOR       | #sl          |                                  |                                                      | 消除偶数相同数                                 |                             |                                                              |
| 模拟：MN                           | #sl          |                                  |                                                      | 模拟                                           |                             | #sl-1=ML621：任务调度器<br />#sl-1=ML767：重构字符串         |
| 贪心：TX                           | #sl          |                                  |                                                      | 最优子结构推出最优解                           |                             |                                                              |
| 单调栈：STK-Mono                   | #jg<br />#sl | ~bl                              |                                                      | 适用于cur与pre多个数进行比较并且操作           |                             | EL496：下一个更大元素 I                                      |
| 递归：RC                           | #sl          |                                  |                                                      | 当某一系列代码执行流程需要重复多次使用时       |                             | ML106：从中序与后序遍历序列构造二叉树                        |
| 链表节点-双向：Node-D              | #jg          |                                  |                                                      |                                                |                             |                                                              |
| 链表节点-单向：Node-S              | #jg          |                                  |                                                      |                                                |                             |                                                              |
| 迭代：DD                           | #sl          |                                  |                                                      |                                                |                             |                                                              |
| ArrayList：ALst                    | #jg          |                                  |                                                      |                                                |                             |                                                              |
| LinkedList：LLst                   | #jg          |                                  |                                                      |                                                |                             |                                                              |
| 分治：DC                           | #sl          |                                  |                                                      |                                                | ~yh：O(log(n))              |                                                              |
| 数学思路：Math                     | #sl          |                                  |                                                      | 用一些数学规则计算出解决问题的方法             |                             |                                                              |
| 滑动窗口个：Win                    | #sl          |                                  |                                                      | 在某些遍历规则下可以运用                       | ML003：无重复字符的最长子串 | HL76：最小覆盖子串<br />ML567：字符串的排列                  |
| 结构模型：JG                       | #sl          |                                  |                                                      |                                                |                             | ML208：实现 Trie (前缀树)<br />EL705：设计哈希集合<br />HL460：LFU 缓存 |
| 逻辑思路：LG                       | #sl          |                                  |                                                      |                                                |                             | HL987：二叉树的垂序遍历                                      |

# 功能-思路映射：哈希表

| #    | 题型样例                                                     | 技术代码        | 思路码点     | 优化                  |
| ---- | ------------------------------------------------------------ | --------------- | ------------ | --------------------- |
|      | EL001:两数之和                                               | HX-M            | #jg          | O(n)<br />O(n)        |
|      | ML003:无重复字符的最长子串                                   | Win             | #sl          | O(n)<br />O(m)        |
|      | ML146：LRU 缓存机制<br />MM16.25：LRU 缓存                   | HX-M            | #jg          |                       |
|      | EL217：存在重复元素<br />EO03：数组中重复的数字              | HX-S            | #jg          | O(n)<br />O(n)        |
|      | HL41：缺失的第一个正数                                       | Arr-idx         | #sl          | O(n)<br />O(1)        |
|      | ML128：最长连续序列                                          | HX-M            | #jg<br />#sl | O(n)<br />O(n)        |
|      | EL013：罗马数字转整数                                        | HX-M            | #jg #sl      | O(n）O(1)             |
|      | EM01.01：判定字符是否唯一                                    | HX-S            | #jg          | O(n) O(n)             |
|      | ML560：和为 K 的子数组                                       | HX-M Arr-PreSum | #jg #sl      | O(n) O(n)             |
|      | ML17：电话号码的字母组合                                     | HX-M BT-Cd      | #jg #sf      | O(3^m^ x 4^n^) O(m+n) |
|      | ML525：连续数组                                              | HX-M Arr-PreSum | #jg #sl      | O(n) O(n)             |
|      | ML105：从前序与中序遍历序列构造二叉树                        | HX-M BT-Cd      | #jg #sf      | O(n) O(n)             |
|      | ML139：单词拆分                                              | HX-S DP-Bd      | #jg #sf      | O(n^2^）O(n)          |
|      | HL815：公交路线                                              | HX-M BFS        | #jg #sf      |                       |
|      | EL349：两个数组的交集                                        | HX-S            | #jg          | O(m+n) O(m+n)         |
|      | ML12：整数转罗马数字                                         | HX-S            | #jg          | O(1) O(1)             |
|      | EL141：环形链表                                              | TP-FS           | #sl          | O(n) O(1)             |
|      | ML142：环形链表 II                                           | TP-FS           | #sl          | O(n) O(1)             |
|      | MO48：最长不含重复字符的子字符串                             | TP-DD           | #sl          | n , 1                 |
|      | EL169：多数元素                                              | HX-M            | #jg          | n , 1                 |
|      | ML347：前 K 个高频元素                                       | HX-M            | #jg #sl      | n , n                 |
|      | ML1488：避免洪水泛滥                                         | HX-M            | #sl          | n^2^ , n              |
|      | ML451：根据字符出现频率排序                                  | HX-M            | #jg          | n+klogk , n+k         |
|      | HL149：直线上最多的点数                                      | HX-M            | #jg          | >n^2^ , n             |
|      | ML138：复制带随机指针的链表<br />MO35：复杂链表的复制        | HX-M BT-Cd      | #jg #sl      | n , n                 |
|      | ML106：从中序与后序遍历序列构造二叉树                        | HX-M RC         | #jg #sl      | n , n                 |
|      | HL76：最小覆盖子串                                           | HX-S HX-M Win   | #jgx2 #sl    | ? , ?                 |
|      | MO07：重建二叉树                                             | HX-M BT-Cd      | #jg #sf      | O(n) O(n)             |
|      | ML621：任务调度器<br />#sl=ML767：重构字符串                 | HX-M MN         | #jg #sl      | ? , ?                 |
|      | EL387：字符串中的第一个唯一字符<br />EO50：第一个只出现一次的字符 | HX-M            | #jg          | n , n                 |
|      | ML567：字符串的排列                                          | HX-M Win        | #jg #sl      |                       |
|      | EO52：两个链表的第一个公共节点<br />EL160：相交链表          | TP-DD           | #sl          | n+m , 1               |
|      | ML454：四数相加 II                                           | HX-M            | #jg          | n^2^ , n^2^           |
|      | EO53：0～n-1中缺失的数字                                     | HX-M BSear      | #jg #sf      |                       |
|      | ML208：实现 Trie (前缀树)                                    |                 | #sl          | ? , ?                 |
|      | MO49：丑数<br />ML264：丑数 II                               | DP-Cd           | #sf          | n , n                 |
|      | EL705：设计哈希集合                                          | JG              | #sl          | n , n                 |
|      | ML49：字母异位词分组                                         | HX-M            | #jg #sl      | ? , ?                 |
|      | HL987：二叉树的垂序遍历                                      | LG              | #sl          | nlogn , n             |
|      | HL460：LFU 缓存                                              | JG              | #sl          | 1 , n                 |
|      | EL496：下一个更大元素 I                                      | HX-M STK-Mono   | #jg #sl      | m+n , n               |
|      | ML424：替换后的最长重复字符                                  | TP-SD Win       | #sl          | n , 26                |
|      | HL1713：得到子序列的最少操作次数                             | TX BSear        | #sf          | n+mlogm , n+m         |

# 已总结题目序号

| 注释 | 题号    | 名称                           | 技巧or注意                                  |
| ---- | ------- | ------------------------------ | ------------------------------------------- |
|      | EL001   | 两数之和                       |                                             |
|      | ML003   | 无重复字符的最长子串           |                                             |
|      | ML12    | 整数转罗马数字                 |                                             |
| @sl  | EL013   | 罗马数字转整数                 |                                             |
|      | ML017   | 电话号码的字母组合             |                                             |
| @sl  | HL041   | 缺失的第一个正数               |                                             |
|      | ML49    | 字母异位词分组                 |                                             |
|      | HL76    | 最小覆盖子串                   |                                             |
|      | ML105   | 从前序与中序遍历序列构造二叉树 | 前序根，中序分                              |
|      | ML106   | 从中序与后序遍历序列构造二叉树 | 后序 = 反序的前序                           |
|      | ML128   | 最长连续序列                   |                                             |
|      | ML138   | 复制带随机指针的链表           |                                             |
|      | ML139   | 单词拆分                       |                                             |
|      | EL141   | 环形链表                       |                                             |
|      | ML142   | 环形链表 II                    |                                             |
|      | ML146   | LRU 缓存机制                   |                                             |
|      | HL149   | 直线上最多的点数               |                                             |
|      | EL160   | 相交链表                       |                                             |
|      | EL169   | 多数元素                       |                                             |
|      | ML208   | 实现 Trie (前缀树)             |                                             |
|      | EL217   | 存在重复元素                   |                                             |
| @sl  | ML264   | 丑数 II                        |                                             |
|      | ML347   | 前 K 个高频元素                |                                             |
|      | EL349   | 两个数组的交集                 |                                             |
|      | EL387   | 字符串中的第一个唯一字符       |                                             |
| @sl  | ML424   | 替换后的最长重复字符           | 滑动窗口边界条件<br />max+k <= right-left+1 |
|      | ML451   | 根据字符出现频率排序           |                                             |
|      | ML454   | 四数相加 II                    |                                             |
|      | HL460   | LFU 缓存                       | 执行时间（方法2）慢                         |
| @sl  | EL496   | 下一个更大元素 I               | Stack比较用法                               |
|      | ML525   | 连续数组                       |                                             |
| @sl  | ML560   | 和为 K 的子数组                |                                             |
|      | ML567   | 字符串的排列                   |                                             |
| @sl  | ML621   | 任务调度器                     |                                             |
|      | EL705   | 设计哈希集合                   |                                             |
| @sl  | ML767   | 重构字符串                     | 与ML621思路相似                             |
| @sl  | HL815   | 公交路线                       |                                             |
| @sl  | HL987   | 二叉树的垂序遍历               | 大体对，细节处优化                          |
|      | ML1488  | 避免洪水泛滥                   | 二分法未必优                                |
| @sl  | HL1713  | 得到子序列的最少操作次数       | 无序转有序，贪心二分>DP                     |
|      |         |                                |                                             |
|      | EO03    | 数组中重复的数字               |                                             |
|      | MO07    | 重建二叉树                     |                                             |
|      | MO35    | 复杂链表的复制                 |                                             |
|      | MO48    | 最长不含重复字符的子字符串     |                                             |
| @sl  | MO49    | 丑数                           |                                             |
|      | EO50    | 第一个只出现一次的字符         |                                             |
|      | EO52    | 两个链表的第一个公共节点       |                                             |
|      | EO53    | 0～n-1中缺失的数字             |                                             |
|      |         |                                |                                             |
|      | EM01.01 | 判定字符是否唯一               |                                             |
|      | MM16.25 | LRU 缓存                       |                                             |

# 部分功能流程

| 代号      | 流程 |
| --------- | ---- |
| BSear     |      |
| BSear-BAr |      |
| NP        |      |
|           |      |
|           |      |
|           |      |

# 零散知识

| 名称：代号           | 详细说明                                | 作用                                                         |
| -------------------- | --------------------------------------- | ------------------------------------------------------------ |
| 普通化头结点：DHead  | 在head节点前面加一个假头结点dHead可解决 | 减少对头结点进行特殊判断的代码量                             |
| 功能：最长公共子序列 | 可将其转换为求两个公共索引              | 其中一个数组作为基准，其索引一定是有序<br />该方法将两个无序数组转化为了一个有序和一个无序的问题 |
|                      |                                         |                                                              |

# QA

| Detail                                                       | Q         | A    |
| ------------------------------------------------------------ | --------- | ---- |
| 空间复杂度：O(\log n)O(logn)，其中 nn 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(\log n)O(logn) 即为排序所需要的空间复杂度。 | O(log(n)) |      |
| 堆排序原理，代码实现，时间复杂度分析                         |           |      |
|                                                              |           |      |

# 代码功能最优实现方法

| 功能代号：代号          | 功能需求                                                     | 功能实现                                                     |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Map初始化：Map-Ini      | 实现初始化赋值                                               | 通过内部代码块实现：<br /> Map<Character, Integer> mp = new HashMap<>() {<br/>            {<br/>                put('I', 1);<br/>                put('V', 5);<br/>                put('X', 10);<br/>                put('L', 50);<br/>                put('C', 100);<br/>                put('D', 500);<br/>                put('M', 1000);<br/>            }<br/>        }; |
| Map值排序：Map-Sort-Val | 实现map值的排序                                              | 将map中的entry添加到list<Map.Entry<>>中<br />用Collcetions.sort自定义comparator来排序 |
| 功能：最大公约数        | 求两数最大公约数                                             | https://zhuanlan.zhihu.com/p/31824895                        |
| 类型转换：List - Map    | 将Map\<String,List\<String>中的values转成List\<List\<String>> | ArrayList<List\<String>>(map.values())                       |
|                         |                                                              |                                                              |
|                         |                                                              |                                                              |
|                         |                                                              |                                                              |

