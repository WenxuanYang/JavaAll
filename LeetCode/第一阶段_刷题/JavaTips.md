1. 查找
   1. 知道key：map
   2. 查找key
      1. 有顺序基准：二分法
         1. 同时可用方法：binary search
2. 最小/大堆
   1. 采用数据结构 priorityqueue
3. 快速冥
   1. 采用分治+递归：LC50
4. 取模
   1. MOD=1e9+7
      1. 加法取模方法：result%MOD
         1. 错误方法：p%MOD+q%MOD
            1. 改正：(p+q)%MOD
5. 动态规划经典方法
   1. 思维核心思想
      1. 填表
      2. 填表时对应的公式
   2. 填表的情况
      1. 如果每个格子对应的答案ans(i,j)可以独立的计算出来，则可以直接用遍历
      2. 如果每个格子对应的答案ans(i,j)可以依据前面的数字计算出来，则方法为递推
   3. 可优化情况：
      1. 例如背包问题，二维数组第一行数据在第一次遍历之后再也不用了，则可以用第二行数据覆盖第一行数据，从而将空间复杂度由二维变成一维，例子见LC518
   4. 经典方法1：01背包
      1. 解决：往规定容量（可等，大于，小于）中填入不确定元素以满足要求
         1. 记忆：定容填充 填鸭式 规模和数量小到大
      2. 解决目标
         1. 容量不确定：最值容量
         2. 容量确定：最值元素个数
   5. 经典方法2：状态递推：LC309
      1. row为不同状态
      2. 列为不同状态的最值或者对应的情况
      3. 记忆：状态递推 分情况讨论 数量小到大 01股票
   6. 经典方法3：定状递推：LC221
      1. 一般数据的状态已经定好
      2. 一般规模小的答案一眼能看出
      3. 一般每个数据对应位置存在一个可选答案
      4. 记忆：01正方形
   7. 经典方法4：倒推思维：LCP07，LC174
      1. 记忆：逆向递推，正向遍历
      2. 适用：正向递推无后效性的时候（即前面的数值不能完全决定后面的数值）
   8. 经典方法5：条件选择：LC300
      1. 使用：f(i) = g(f(j))，其中j为递推中比i小但是条件选择出的元素，并不一定是i前一个元素
